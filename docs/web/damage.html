<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>ダメージ計算ツール</title>
  <link rel="stylesheet" href="../theme.css?v3" />
  <style>
    .form-grid {
      display: grid;
      gap: 12px;
    }

    .form-sections {
      display: grid;
      gap: 12px;
    }

    .input-card {
      padding: 12px;
      border-radius: 12px;
      display: grid;
      gap: 12px;
    }

    .input-card h4 {
      margin: 0;
    }

    .result-panel {
      position: sticky;
      top: 8px;
      z-index: 5;
      margin-top: 10px;
      margin-bottom: 14px;
    }

    .input-row {
      display: grid;
      grid-template-columns: 140px minmax(0, 1fr);
      gap: 8px 10px;
      align-items: center;
    }

    .input-row label {
      font-weight: 600;
      margin: 0;
    }

    .input-row input,
    .input-row select {
      grid-column: 2;
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--md-sys-outline-variant);
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface);
      font-size: 0.95rem;
    }

    .input-row input[type="hidden"] {
      display: none;
    }

    .input-row .chip-group {
      grid-column: 2;
    }

    .toggle-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--md-sys-outline-variant);
      background: var(--md-sys-surface);
    }

    .toggle-item input {
      width: 18px;
      height: 18px;
    }

    .result-card {
      display: grid;
      gap: 6px;
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--md-sys-surface);
      border: 1px solid var(--md-sys-outline-variant);
    }

    .result-row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
    }

    .result-label {
      color: var(--md-sys-on-surface-variant);
      font-size: 0.9rem;
      text-transform: none;
      letter-spacing: normal;
    }

    .result-value {
      font-size: 1rem;
      font-weight: 700;
      text-align: right;
    }

    .chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip-button {
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      border: 1px solid var(--md-sys-outline-variant);
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface-variant);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .chip-button.is-active {
      background: color-mix(in srgb, var(--md-sys-primary-container) 70%, var(--md-sys-surface));
      color: var(--md-sys-on-primary-container);
      border-color: transparent;
      box-shadow: 0 6px 12px color-mix(in srgb, var(--md-sys-shadow) 60%, transparent);
    }

    .chip-button[data-value="physical"] {
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface);
      border-color: #f2f2f2;
    }

    .chip-button[data-value="element"] {
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface);
      border-color: #e85757;
    }

    .chip-button[data-value="void"] {
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface-variant);
      border-color: #8a8a8a;
    }

    .chip-button.is-active[data-value="physical"] {
      background: color-mix(in srgb, #ffffff 70%, var(--md-sys-surface));
      color: #1a1b21;
      box-shadow: 0 0 0 1px color-mix(in srgb, #ffffff 70%, transparent);
    }

    .chip-button.is-active[data-value="element"] {
      background: linear-gradient(135deg, rgba(232, 87, 87, 0.8), rgba(81, 142, 255, 0.8));
      color: #130505;
      border-color: transparent;
      box-shadow: 0 0 0 1px color-mix(in srgb, #e85757 60%, transparent);
    }

    .chip-button.is-active[data-value="void"] {
      background: color-mix(in srgb, #8a8a8a 70%, var(--md-sys-surface));
      color: #151515;
      box-shadow: 0 0 0 1px color-mix(in srgb, #8a8a8a 70%, transparent);
    }

    .hint {
      margin: 0;
      font-size: 0.9rem;
      color: var(--md-sys-on-surface-variant);
      line-height: 1.6;
    }

    .is-hidden {
      display: none;
    }

    @media (max-width: 640px) {
      .input-row {
        grid-template-columns: 110px minmax(0, 1fr);
      }
    }

    @media (min-width: 960px) {
      .form-sections {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .input-card--skill {
        grid-column: 1 / -1;
      }
    }
  </style>
</head>

<body>
  <main>
    <header class="reveal">
      <p class="subtitle">Eldersign Toolkit</p>
      <h1>ダメージ計算ツール</h1>
      <p class="subtitle">仮置き。行動順と自動入力を後で入れたい</p>
      <div class="nav-links">
        <a class="button secondary" href="../index.html">ツール集へ戻る</a>
      </div>
    </header>

    <section class="reveal">
      <div class="result-panel">
        <div class="result-card">
          <div class="result-row">
            <div class="result-label">ダメージ(乱数前)</div>
            <div class="result-value" id="atk-damage-base">-</div>
          </div>
          <div class="result-row">
            <div class="result-label">乱数範囲</div>
            <div class="result-value" id="atk-damage-range">-</div>
          </div>
          <div class="result-row">
            <div class="result-label">命中率</div>
            <div class="result-value" id="hit-raw">-</div>
          </div>
        </div>
      </div>
      <div class="form-sections">
        <div class="input-card surface-card input-card--skill">
          <h4>スキル性能</h4>
          <div class="input-row">
              <label for="skill-type">種別</label>
              <input type="hidden" id="skill-type" value="attack" />
              <div class="chip-group" data-chip-target="skill-type">
                <button type="button" class="chip-button is-active" data-value="attack">攻撃・吸収</button>
                <button type="button" class="chip-button" data-value="heal">付与・回復</button>
              </div>
          </div>
          <div class="input-row">
              <label for="skill-coeff">係数</label>
              <input id="skill-coeff" type="number" min="0" step="0.1" value="100" />
          </div>
          <div class="input-row">
              <label for="hit-skill">命中</label>
              <input id="hit-skill" type="number" min="0" step="1" value="120" />
            </div>
            <div class="input-row">
              <label for="skill-source">ソース(複数はカンマ区切り)</label>
              <input id="skill-source" type="text" placeholder="例: 1200, 1500" />
            </div>
          <div class="input-row mode-attack">
              <label for="skill-attr">属性</label>
              <input type="hidden" id="skill-attr" value="physical" />
              <div class="chip-group" data-chip-target="skill-attr">
                <button type="button" class="chip-button is-active" data-value="physical">物理</button>
                <button type="button" class="chip-button" data-value="element">炎冷</button>
                <button type="button" class="chip-button" data-value="void">虚軸</button>
              </div>
          </div>
        </div>

        <div class="input-card surface-card">
          <h4>攻撃側ステータス</h4>
          <div class="input-row">
              <label for="skill-apt-passive">P適正(%)</label>
              <input id="skill-apt-passive" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-apt-active">A適正(%)</label>
              <input id="skill-apt-active" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-buff">強化(%)</label>
              <input id="skill-buff" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-seal">封技/封術Lv</label>
              <input id="skill-seal" type="number" min="0" max="10" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="hit-attacker">命中</label>
              <input id="hit-attacker" type="number" min="0" step="1" value="0" />
            </div>
          <div class="input-row">
              <label for="hit-dizzy-attacker">眩暈Lv</label>
              <input id="hit-dizzy-attacker" type="number" min="0" max="10" step="1" value="0" />
          </div>
          <label class="toggle-item">
              <input id="hit-after" type="checkbox" />
              <span>後攻補正 +100%</span>
          </label>
          <label class="toggle-item">
              <input id="hit-monarch" type="checkbox" />
              <span>君主補正 +50%</span>
          </label>
          <label class="toggle-item">
              <input id="hit-eye" type="checkbox" />
              <span>アビリティ神眼(上限99/下限30)</span>
          </label>
        </div>

        <div class="input-card surface-card">
          <h4>防御側ステータス</h4>
          <div class="input-row mode-attack">
              <label for="def-value">防御</label>
              <input id="def-value" type="number" min="0" step="1" value="3000" />
          </div>
          <div class="input-row">
              <label for="skill-resist-passive">P耐性(%)</label>
              <input id="skill-resist-passive" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-resist-active">A耐性(%)</label>
              <input id="skill-resist-active" type="number" step="1" value="0" />
          </div>
          <div class="input-row mode-attack">
              <label for="def-alert">隙</label>
              <input id="def-alert" type="number" min="0" max="100" step="1" value="0" />
          </div>
          <div class="input-row mode-attack">
              <label for="union-reduce">ユニオン補正(%)</label>
              <input id="union-reduce" type="number" min="0" max="10" step="1" value="10" />
          </div>
          <div class="input-row">
              <label for="hit-defender">敏捷</label>
              <input id="hit-defender" type="number" min="0" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="hit-dizzy-defender">眩暈Lv</label>
              <input id="hit-dizzy-defender" type="number" min="0" max="10" step="1" value="0" />
          </div>
          <label class="toggle-item mode-attack">
              <input id="def-hardening" type="checkbox" />
              <span>硬化Lv10</span>
          </label>
          <label class="toggle-item mode-attack">
              <input id="def-critical" type="checkbox" />
              <span>クリティカル</span>
          </label>
        </div>
      </div>
      <p class="hint">
        耐性補正=(100-耐性(P))% × (100-耐性(A))%、適正補正=(100+適正(P))% × (100+適正(A))%。
      </p>
    </section>
  </main>

  <script>
    (() => {
      const RANDOM_MIN = 0.875;
      const RANDOM_MAX = 1.125;
      const STORAGE_KEY = "eldersign_damage_form_v1";

      const inputs = {
        skillType: document.getElementById("skill-type"),
        skillCoeff: document.getElementById("skill-coeff"),
        skillSource: document.getElementById("skill-source"),
        skillAttr: document.getElementById("skill-attr"),
        skillResistPassive: document.getElementById("skill-resist-passive"),
        skillResistActive: document.getElementById("skill-resist-active"),
        skillAptPassive: document.getElementById("skill-apt-passive"),
        skillAptActive: document.getElementById("skill-apt-active"),
        skillBuff: document.getElementById("skill-buff"),
        skillSeal: document.getElementById("skill-seal"),
        defValue: document.getElementById("def-value"),
        defAlert: document.getElementById("def-alert"),
        defHardening: document.getElementById("def-hardening"),
        defCritical: document.getElementById("def-critical"),
        unionReduce: document.getElementById("union-reduce"),
        hitSkill: document.getElementById("hit-skill"),
        hitAttacker: document.getElementById("hit-attacker"),
        hitDefender: document.getElementById("hit-defender"),
        hitDizzyAttacker: document.getElementById("hit-dizzy-attacker"),
        hitDizzyDefender: document.getElementById("hit-dizzy-defender"),
        hitAfter: document.getElementById("hit-after"),
        hitMonarch: document.getElementById("hit-monarch"),
        hitEye: document.getElementById("hit-eye"),
      };

      const outputs = {
        atkDamageBase: document.getElementById("atk-damage-base"),
        atkDamageRange: document.getElementById("atk-damage-range"),
        hitRaw: document.getElementById("hit-raw"),
      };

      function readNumber(input) {
        const value = Number(input.value);
        return Number.isFinite(value) ? value : 0;
      }

      function formatNumber(value, digits = 1) {
        if (!Number.isFinite(value)) return "-";
        return value.toFixed(digits);
      }

      function formatDamage(value) {
        if (!Number.isFinite(value)) return "-";
        return String(Math.ceil(value));
      }

      function setChipValue(input, value) {
        if (!input || value == null) return;
        const strValue = String(value);
        input.value = strValue;
        const group = document.querySelector(`.chip-group[data-chip-target="${input.id}"]`);
        if (!group) return;
        group.querySelectorAll(".chip-button").forEach((button) => {
          const isActive = button.dataset.value === strValue;
          button.classList.toggle("is-active", isActive);
        });
      }

      function parseNumberList(text) {
        if (!text) return [];
        return text
          .split(/[,\s]+/)
          .map((v) => Number(v))
          .filter((v) => Number.isFinite(v));
      }

      function average(values) {
        if (values.length === 0) return 0;
        const sum = values.reduce((acc, v) => acc + v, 0);
        return sum / values.length;
      }

      function calcSkillPower() {
        const coeff = readNumber(inputs.skillCoeff);
        const sources = parseNumberList(inputs.skillSource.value);
        const avgSource = average(sources);
        const atkConst = getAttackConst(inputs.skillAttr.value);
        if (atkConst <= 0 || avgSource <= 0) {
          return { value: 0, meta: "ソースか定数が未入力のため0" };
        }
        const value = coeff * Math.sqrt(avgSource / atkConst);
        const meta = `ソース平均 ${formatNumber(avgSource, 1)} / 定数 ${atkConst}`;
        return { value, meta };
      }

      function getAttackConst(attr) {
        switch (attr) {
          case "physical":
            return 5;
          case "element":
            return 9;
          case "void":
            return 20;
          default:
            return 0;
        }
      }

      function getDefenseConst(attr) {
        switch (attr) {
          case "physical":
            return 500;
          case "element":
            return 120;
          case "void":
            return 10;
          default:
            return 0;
        }
      }

      function calcDefenseConst() {
        const baseConst = getDefenseConst(inputs.skillAttr.value);
        const isPhysical = inputs.skillAttr.value === "physical";
        const hardening = inputs.defHardening.checked;
        const critical = inputs.defCritical.checked;

        if (critical) {
          if (hardening && isPhysical) return 500;
          return 0;
        }
        if (hardening) {
          if (isPhysical) return 2000;
          return 0;
        }
        return baseConst;
      }

      function calcDefensePower() {
        const defConst = calcDefenseConst();
        const defense = readNumber(inputs.defValue);
        const alert = readNumber(inputs.defAlert);
        if (defConst <= 0 || defense <= 0) {
          return { value: 0, meta: "定数または防御が0のため0" };
        }
        const base = Math.sqrt(defConst * defense);
        const value = base * (1 - alert / 100);
        const meta = `定数 ${defConst} × 防御 ${formatNumber(defense, 0)} × 隙 ${formatNumber(
          100 - alert,
          1
        )}%`;
        return { value, meta };
      }

      function normalizeProper(value) {
        if (value <= -100) return -100;
        if (value > 100) return Math.sqrt(100 * value);
        return value;
      }

      function normalizeTolerant(value) {
        if (value < -100) return -Math.sqrt(-100 * value);
        return value;
      }

      function calcResAptMultiplier(resistP, resistA, aptP, aptA) {
        const tolerantP = normalizeTolerant(resistP);
        const tolerantA = normalizeTolerant(resistA);
        const properP = normalizeProper(aptP);
        const properA = normalizeProper(aptA);
        const resPctP = 100 - tolerantP;
        const resPctA = 100 - tolerantA;
        const aptPctP = 100 + properP;
        const aptPctA = 100 + properA;
        return {
          res: (resPctP / 100) * (resPctA / 100),
          apt: (aptPctP / 100) * (aptPctA / 100),
          resPctP,
          resPctA,
          aptPctP,
          aptPctA,
        };
      }

      function calcOtherMultiplier(buff) {
        return 1 + buff / 100;
      }

      function updateAttack() {
        const skill = calcSkillPower();
        const defense = calcDefensePower();

        const resistP = readNumber(inputs.skillResistPassive);
        const resistA = readNumber(inputs.skillResistActive);
        const aptP = readNumber(inputs.skillAptPassive);
        const aptA = readNumber(inputs.skillAptActive);
        const ra = calcResAptMultiplier(resistP, resistA, aptP, aptA);
        const other = calcOtherMultiplier(readNumber(inputs.skillBuff));
        const seal = readNumber(inputs.skillSeal);
        const sealMultiplier = 1 - seal / 10;

        const base = skill.value * ra.res * ra.apt * other * sealMultiplier - defense.value;
        const unionReduce = Math.min(10, Math.max(0, readNumber(inputs.unionReduce)));
        const unionMultiplier = 1 - unionReduce / 100;
        const unioned = base * unionMultiplier;

        outputs.atkDamageBase.textContent = formatDamage(unioned);

        const minDamage = unioned * RANDOM_MIN;
        const maxDamage = unioned * RANDOM_MAX;
        outputs.atkDamageRange.textContent = `${formatDamage(minDamage)} ～ ${formatDamage(maxDamage)}`;
      }

      function updateHeal() {
        const coeff = readNumber(inputs.skillCoeff);
        const sources = parseNumberList(inputs.skillSource.value);
        const avgSource = average(sources);
        const resistP = readNumber(inputs.skillResistPassive);
        const resistA = readNumber(inputs.skillResistActive);
        const aptP = readNumber(inputs.skillAptPassive);
        const aptA = readNumber(inputs.skillAptActive);
        const ra = calcResAptMultiplier(resistP, resistA, aptP, aptA);
        const other = calcOtherMultiplier(readNumber(inputs.skillBuff));
        const seal = readNumber(inputs.skillSeal);
        const sealMultiplier = 1 - seal / 10;

        const base = coeff * Math.sqrt(avgSource * 0.2) * ra.res * ra.apt * other * sealMultiplier;
        outputs.atkDamageBase.textContent = formatDamage(base);
        outputs.atkDamageRange.textContent = "-";
      }

      function updateHit() {
        const skillHit = readNumber(inputs.hitSkill);
        const attackerHit = readNumber(inputs.hitAttacker);
        const defenderAgi = readNumber(inputs.hitDefender);
        const alert = readNumber(inputs.defAlert);
        const dizzyAttacker = readNumber(inputs.hitDizzyAttacker);
        const dizzyDefender = readNumber(inputs.hitDizzyDefender);
        const after = inputs.hitAfter.checked ? 2 : 1;
        const monarch = inputs.hitMonarch.checked ? 1.5 : 1;

        const raw =
          70 +
          Math.sqrt(5) *
            (skillHit *
              (1 - dizzyAttacker / 10) *
              (Math.sqrt(attackerHit) / 100) -
              (1 - alert / 100) * (1 - dizzyDefender / 10) * Math.sqrt(defenderAgi));
        const corrected = raw * after * monarch;
        const caps = inputs.hitEye.checked ? { max: 99, min: 30 } : { max: 95, min: 20 };
        const capped = Math.min(caps.max, Math.max(caps.min, corrected));
        const final = Math.floor(capped);

        outputs.hitRaw.textContent = `${formatNumber(final, 0)}%`;
      }

      function updateAll() {
        updateModeUI();
        if (inputs.skillType.value === "attack") {
          updateAttack();
        } else {
          updateHeal();
        }
        updateHit();
        saveFormState();
      }

      function saveFormState() {
        const state = {};
        Object.entries(inputs).forEach(([key, input]) => {
          if (!input) return;
          state[key] = input.type === "checkbox" ? input.checked : input.value;
        });
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (error) {
          // Ignore storage failures (private mode, quota, etc.)
        }
      }

      function loadFormState() {
        let state = null;
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          state = raw ? JSON.parse(raw) : null;
        } catch (error) {
          state = null;
        }
        if (!state || typeof state !== "object") return;
        Object.entries(inputs).forEach(([key, input]) => {
          if (!input || !(key in state)) return;
          if (input.type === "checkbox") {
            input.checked = Boolean(state[key]);
            return;
          }
          input.value = String(state[key]);
        });
        setChipValue(inputs.skillType, inputs.skillType.value);
        setChipValue(inputs.skillAttr, inputs.skillAttr.value);
      }

      function updateModeUI() {
        const isAttack = inputs.skillType.value === "attack";
        document.querySelectorAll(".mode-attack").forEach((el) => {
          el.classList.toggle("is-hidden", !isAttack);
        });
      }

      Object.values(inputs).forEach((input) => {
        if (!input) return;
        const eventName = input.type === "checkbox" ? "change" : "input";
        input.addEventListener(eventName, updateAll);
      });

      document.querySelectorAll(".chip-group").forEach((group) => {
        group.addEventListener("click", (event) => {
          const button = event.target.closest(".chip-button");
          if (!button || !group.contains(button)) return;
          const targetId = group.dataset.chipTarget;
          if (!targetId) return;
          const input = document.getElementById(targetId);
          if (!input) return;
          setChipValue(input, button.dataset.value);
          updateAll();
        });
      });

      loadFormState();
      updateAll();
    })();
  </script>
  <script src="../footer.js" defer></script>
</body>

</html>
